//
// Note: fc - prefix for flex class
//

/*
 * Container
 */
.flex,
.fc {
  height: 100%;
  display: flex;
  flex-flow: row wrap;
  align-content: stretch
}


/*
 * flex-direction
 *
 * row (default):
 *    left to right in ltr; right to left in rtl
 * row-reverse:
 *    right to left in ltr; left to right in rtl
 * column:
 *    same as row but top to bottom
 * column-reverse:
 *    same as row-reverse but bottom to top
 */
.flex.flex-row,
.fc-row {
  flex-direction: row /* default */
}

.flex.flex-row-reverse,
.fc-row-reverse {
  flex-direction: row-reverse
}

.flex.flex-column,
.fc-col {
  flex-direction: column
}

.flex.flex-column-reverse,
.fc-col-reverse {
  flex-direction: column-reverse
}


/*
 * flex-wrap
 *
 * nowrap (default):
 *    single-line / left to right in ltr; right to left in rtl
 * wrap:
 *    multi-line / left to right in ltr; right to left in rtl
 * wrap-reverse:
 *    multi-line / right to left in ltr; left to right in rtl
 */
.flex.flex-nowrap,
.fc-nowrap {
  flex-wrap: nowrap /* default */
}


/*
 * justify-content
 *
 * flex-start (default):
 *    items are packed toward the start line
 * flex-end:
 *    items are packed toward to end line
 * center:
 *    items are centered along the line
 * space-between:
 *    items are evenly distributed in the line; first item is on the start line, last item on the end line
 * space-around:
 *    items are evenly distributed in the line with equal space around them. Note that visually the spaces
 *    aren't equal, since all the items have equal space on both sides. The first item will have one unit
 *    of space against the container edge, but two units of space between the next item because that next
 *    item has its own spacing that applies.
 */
.flex.flex-justify-start,
.fc-left {
  justify-content: flex-start /* default */
}

.flex.flex-justify-end,
.fc-right {
  justify-content: flex-end
}

.flex.flex-justify-center,
.fc-center {
  justify-content: center
}

.flex.flex-justify-space-between,
.fc-between {
  justify-content: space-between
}

.flex.flex-justify-space-around,
.fc-around {
  justify-content: space-around
}


/*
 * align-items
 *
 * flex-start:
 *    cross-start margin edge of the items is placed on the cross-start line
 * flex-end:
 *    cross-end margin edge of the items is placed on the cross-end line
 * center:
 *    items are centered in the cross-axis
 * baseline:
 *    items are aligned such as their baselines align
 * stretch (default):
 *    stretch to fill the container (still respect min-width/max-width)
 */
.flex.flex-align-start,
.fc-top {
  align-items: flex-start
}

.flex.flex-align-end,
.fc-bottom {
  align-items: flex-end
}

.flex.flex-align-center,
.fc-middle {
  align-items: flex-center
}

.flex.flex-align-baseline,
.fc-baseline {
  align-items: baseline
}

.flex.flex-align-stretch,
.fc-stretch {
  align-items: stretch /* default */
}


/*
 * Items
 */
.flex-item,
.fc-item {
  order: 0; /* fallback if attr() is not supported for properties other than content */
  order: attr(flex-order number, 0);
  flex: 0 1 auto /* default */
}


/*
 * align-self
 *
 * This allows the default alignment (or the one specified by align-items)
 * to be overridden for individual flex items.
 */
.flex-item.flex-align-start,
.fc-item-top {
  align-self: flex-start
}

.flex-item.flex-align-end,
.fc-item-bottom {
  align-self: flex-end
}

.flex-item.flex-align-center,
.fc-item-middle {
  align-self: center
}

.flex-item.flex-align-baseline,
.fc-item-baseline {
  align-self: baseline
}

.flex-item.flex-align-stretch,
.fc-item-stretch {
  align-self: stretch
}
